Content-Type: text/plain
<html lang="en"><head><style shadowcssshim="">style { display: none !important; }
</style><style shadowcssshim="">template { display: none; }</style>
<!--
This test runs the TodoMVC app, adds a few elements, marks some as done, and
switches from back and forth between "Active" and "All". This will make some
nodes to be hidden and readded to the page.

This is a regression test for a bug in dwc that made the nodes appear in the
wrong order when using lists and ifs together.
-->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
  <link rel="stylesheet" href="../../../web/base.css">
  <script src="../../packages/polymer/testing/testing.js"></script>
  <title>Dart • TodoMVC</title>
<style>template,
thead[template],
tbody[template],
tfoot[template],
th[template],
tr[template],
td[template],
caption[template],
colgroup[template],
col[template],
option[template] {
  display: none;
}</style></head>
<body><polymer-element name="todo-row" extends="li" attributes="todo">
  <template>
    <style scoped="">
.todo-item {
  position: relative;
  font-size: 24px;
  border-bottom: 1px dotted #ccc;
}

.todo-item.editing {
  border-bottom: none;
  padding: 0;
}

/*
TODO(jmesserly): the ".todo-item label" selector does not work with real
ShadowRoot because it crosses the shadow boundary.
*/
.todo-item.completed [is=editable-label] {
  color: #a9a9a9;
  text-decoration: line-through;
}

.todo-item .toggle {
  text-align: center;
  width: 40px;
  /* auto, since non-WebKit browsers don't support input styling */
  height: auto;
  position: absolute;
  top: 0;
  bottom: 0;
  margin: auto 0;
  border: none; /* Mobile Safari */
  -webkit-appearance: none;
  /*-moz-appearance: none;*/
  -ms-appearance: none;
  -o-appearance: none;
  appearance: none;
}

.todo-item .toggle:after {
  content: '✔';
  line-height: 43px; /* 40 + a couple of pixels visual adjustment */
  font-size: 20px;
  color: #d9d9d9;
  text-shadow: 0 -1px 0 #bfbfbf;
}

.todo-item .toggle:checked:after {
  color: #85ada7;
  text-shadow: 0 1px 0 #669991;
  bottom: 1px;
  position: relative;
}
.todo-item .destroy {
  display: none;
  position: absolute;
  top: 0;
  right: 10px;
  bottom: 0;
  width: 40px;
  height: 40px;
  margin: auto 0;
  font-size: 22px;
  color: #a88a8a;
  -webkit-transition: all 0.2s;
  -moz-transition: all 0.2s;
  -ms-transition: all 0.2s;
  -o-transition: all 0.2s;
  transition: all 0.2s;
}

.todo-item .destroy:hover {
  text-shadow: 0 0 1px #000,
         0 0 10px rgba(199, 107, 107, 0.8);
  -webkit-transform: scale(1.3);
  -moz-transform: scale(1.3);
  -ms-transform: scale(1.3);
  -o-transform: scale(1.3);
  transform: scale(1.3);
}

.todo-item .destroy:after {
  content: '✖';
}

.todo-item:hover .destroy {
  display: block;
}

.todo-item.editing .destroy,
.todo-item.editing .toggle {
  display: none;
}

.todo-item.editing:last-child {
  margin-bottom: -1px;
}

/*
  Hack to remove background from Mobile Safari.
  Can't use it globally since it destroys checkboxes in Firefox and Opera
*/
@media screen and (-webkit-min-device-pixel-ratio:0) {
  .todo-item .toggle {
    background: none;
  }
  #todo-item .toggle {
    height: 40px;
  }
}
    </style>
    <div class="todo-item">
      <input class="toggle" type="checkbox" checked="{{todo.done}}">
      <editable-label id="label" value="{{todo.task}}"></editable-label>
      <button class="destroy" on-click="removeTodo"></button>
    </div>
  </template>
  
</polymer-element>
<polymer-element name="todo-app">
<template>
  <section id="todoapp">
    <header id="header">
      <h1 class="title">todos</h1>
      <form on-submit="addTodo">
        <input id="new-todo" placeholder="What needs to be done?" autofocus="" on-change="addTodo">
      </form>
    </header>
    <section id="main">
      <input id="toggle-all" type="checkbox" checked="{{app.allChecked}}">
      <label for="toggle-all"></label>
      <ul id="todo-list">
        <template repeat="{{app.visibleTodos}}">
          <li is="todo-row" todo="{{}}"></li>
        </template>
      </ul>
    </section>
    <template bind="" if="{{app.todos.length &gt; 0}}">
      <footer id="footer">
        <span id="todo-count"><strong>{{app.remaining}}</strong></span>
        <ul is="router-options" id="filters">
          <li> <a href="#/">All</a> </li>
          <li> <a href="#/active">Active</a> </li>
          <li> <a href="#/completed">Completed</a> </li>
        </ul>
        <template bind="" if="{{app.hasCompleteTodos}}">
          <button id="clear-completed" on-click="clear">
            Clear completed ({{app.doneCount}})
          </button>
        </template>
      </footer>
    </template>
  </section>
  <footer id="info">
    <p>Double-click to edit a todo.</p>
    <p>Credits: the <a href="http://www.dartlang.org">Dart</a> team.</p>
    <p>
      Learn more about
      <a href="https://www.dartlang.org/articles/dart-web-components/">Dart + Web Components</a>
      or
      <a href="https://github.com/dart-lang/web-ui/tree/master/example/todomvc">view the source</a>.
    </p>
    <p>Part of <a href="http://todomvc.com">TodoMVC</a>.</p>
  </footer>
</template>

</polymer-element>
<polymer-element name="router-options" extends="ul">
  <template><content></content></template>
  
</polymer-element>
<polymer-element name="editable-label" attributes="value">
  <template>
    <template bind="" if="{{!editing}}">
      <label class="edit-label" on-double-click="edit">{{value}}</label>
    </template>
    <template bind="" if="{{editing}}">
      <form on-submit="update">
        <input id="edit" class="edit editing" on-blur="update" on-key-up="maybeCancel">
      </form>
    </template>
  </template>
  
</polymer-element>

  <todo-app><shadow-root>
  <section id="todoapp">
    <header id="header">
      <h1 class="title">todos</h1>
      <form on-submit="addTodo">
        <input id="new-todo" placeholder="What needs to be done?" autofocus="" on-change="addTodo">
      </form>
    </header>
    <section id="main">
      <input id="toggle-all" type="checkbox">
      <label for="toggle-all"></label>
      <ul id="todo-list">
        <template repeat="{{app.visibleTodos}}"></template>
          <li is="todo-row" todo="{{}}"><shadow-root>
    <style scoped="">todo-row .todo-item, [is=todo-row] .todo-item {
	position: relative; font-size: 24px; border-bottom-width: 1px; border-bottom-style: dotted; border-bottom-color: rgb(204, 204, 204);
}

todo-row .todo-item.editing, [is=todo-row] .todo-item.editing {
	border-bottom-style: none; padding: 0px;
}

todo-row .todo-item.completed [is="editable-label"], [is=todo-row] .todo-item.completed [is="editable-label"] {
	color: rgb(169, 169, 169); text-decoration: line-through;
}

todo-row .todo-item .toggle, [is=todo-row] .todo-item .toggle {
	text-align: center; width: 40px; height: auto; position: absolute; top: 0px; bottom: 0px; margin: auto 0px; border: none; -webkit-appearance: none;
}

todo-row .todo-item .toggle::after, [is=todo-row] .todo-item .toggle::after {
	content: '✔'; line-height: 43px; font-size: 20px; color: rgb(217, 217, 217); text-shadow: rgb(191, 191, 191) 0px -1px 0px;
}

todo-row .todo-item .toggle:checked::after, [is=todo-row] .todo-item .toggle:checked::after {
	color: rgb(133, 173, 167); text-shadow: rgb(102, 153, 145) 0px 1px 0px; bottom: 1px; position: relative;
}

todo-row .todo-item .destroy, [is=todo-row] .todo-item .destroy {
	display: none; position: absolute; top: 0px; right: 10px; bottom: 0px; width: 40px; height: 40px; margin: auto 0px; font-size: 22px; color: rgb(168, 138, 138); transition: all 0.2s; -webkit-transition: all 0.2s;
}

todo-row .todo-item .destroy:hover, [is=todo-row] .todo-item .destroy:hover {
	text-shadow: rgb(0, 0, 0) 0px 0px 1px, rgba(199, 107, 107, 0.8) 0px 0px 10px; -webkit-transform: scale(1.3);
}

todo-row .todo-item .destroy::after, [is=todo-row] .todo-item .destroy::after {
	content: '✖';
}

todo-row .todo-item:hover .destroy, [is=todo-row] .todo-item:hover .destroy {
	display: block;
}

todo-row .todo-item.editing .destroy, [is=todo-row] .todo-item.editing .destroy, todo-row .todo-item.editing .toggle, [is=todo-row] .todo-item.editing .toggle {
	display: none;
}

todo-row .todo-item.editing:last-child, [is=todo-row] .todo-item.editing:last-child {
	margin-bottom: -1px;
}

@media screen and (-webkit-min-device-pixel-ratio: 0) {
todo-row .todo-item .toggle, [is=todo-row] .todo-item .toggle {
	background-image: none; background-position: initial initial; background-repeat: initial initial;
}

todo-row #todo-item .toggle, [is=todo-row] #todo-item .toggle {
	height: 40px;
}


}

</style>
    <div class="todo-item">
      <input class="toggle" type="checkbox">
      <editable-label id="label" value="{{todo.task}}"><shadow-root>
    <template bind="" if="{{!editing}}"></template>
      <label class="edit-label" on-double-click="edit">one (unchecked)</label>
    
    <template bind="" if="{{editing}}"></template>
  </shadow-root></editable-label>
      <button class="destroy" on-click="removeTodo"></button>
    </div>
  </shadow-root></li>
        
          <li is="todo-row" todo="{{}}"><shadow-root>
    <style scoped="">todo-row .todo-item, [is=todo-row] .todo-item {
	position: relative; font-size: 24px; border-bottom-width: 1px; border-bottom-style: dotted; border-bottom-color: rgb(204, 204, 204);
}

todo-row .todo-item.editing, [is=todo-row] .todo-item.editing {
	border-bottom-style: none; padding: 0px;
}

todo-row .todo-item.completed [is="editable-label"], [is=todo-row] .todo-item.completed [is="editable-label"] {
	color: rgb(169, 169, 169); text-decoration: line-through;
}

todo-row .todo-item .toggle, [is=todo-row] .todo-item .toggle {
	text-align: center; width: 40px; height: auto; position: absolute; top: 0px; bottom: 0px; margin: auto 0px; border: none; -webkit-appearance: none;
}

todo-row .todo-item .toggle::after, [is=todo-row] .todo-item .toggle::after {
	content: '✔'; line-height: 43px; font-size: 20px; color: rgb(217, 217, 217); text-shadow: rgb(191, 191, 191) 0px -1px 0px;
}

todo-row .todo-item .toggle:checked::after, [is=todo-row] .todo-item .toggle:checked::after {
	color: rgb(133, 173, 167); text-shadow: rgb(102, 153, 145) 0px 1px 0px; bottom: 1px; position: relative;
}

todo-row .todo-item .destroy, [is=todo-row] .todo-item .destroy {
	display: none; position: absolute; top: 0px; right: 10px; bottom: 0px; width: 40px; height: 40px; margin: auto 0px; font-size: 22px; color: rgb(168, 138, 138); transition: all 0.2s; -webkit-transition: all 0.2s;
}

todo-row .todo-item .destroy:hover, [is=todo-row] .todo-item .destroy:hover {
	text-shadow: rgb(0, 0, 0) 0px 0px 1px, rgba(199, 107, 107, 0.8) 0px 0px 10px; -webkit-transform: scale(1.3);
}

todo-row .todo-item .destroy::after, [is=todo-row] .todo-item .destroy::after {
	content: '✖';
}

todo-row .todo-item:hover .destroy, [is=todo-row] .todo-item:hover .destroy {
	display: block;
}

todo-row .todo-item.editing .destroy, [is=todo-row] .todo-item.editing .destroy, todo-row .todo-item.editing .toggle, [is=todo-row] .todo-item.editing .toggle {
	display: none;
}

todo-row .todo-item.editing:last-child, [is=todo-row] .todo-item.editing:last-child {
	margin-bottom: -1px;
}

@media screen and (-webkit-min-device-pixel-ratio: 0) {
todo-row .todo-item .toggle, [is=todo-row] .todo-item .toggle {
	background-image: none; background-position: initial initial; background-repeat: initial initial;
}

todo-row #todo-item .toggle, [is=todo-row] #todo-item .toggle {
	height: 40px;
}


}

</style>
    <div class="todo-item completed">
      <input class="toggle" type="checkbox">
      <editable-label id="label" value="{{todo.task}}"><shadow-root>
    <template bind="" if="{{!editing}}"></template>
      <label class="edit-label" on-double-click="edit">two (checked)</label>
    
    <template bind="" if="{{editing}}"></template>
  </shadow-root></editable-label>
      <button class="destroy" on-click="removeTodo"></button>
    </div>
  </shadow-root></li>
        
          <li is="todo-row" todo="{{}}"><shadow-root>
    <style scoped="">todo-row .todo-item, [is=todo-row] .todo-item {
	position: relative; font-size: 24px; border-bottom-width: 1px; border-bottom-style: dotted; border-bottom-color: rgb(204, 204, 204);
}

todo-row .todo-item.editing, [is=todo-row] .todo-item.editing {
	border-bottom-style: none; padding: 0px;
}

todo-row .todo-item.completed [is="editable-label"], [is=todo-row] .todo-item.completed [is="editable-label"] {
	color: rgb(169, 169, 169); text-decoration: line-through;
}

todo-row .todo-item .toggle, [is=todo-row] .todo-item .toggle {
	text-align: center; width: 40px; height: auto; position: absolute; top: 0px; bottom: 0px; margin: auto 0px; border: none; -webkit-appearance: none;
}

todo-row .todo-item .toggle::after, [is=todo-row] .todo-item .toggle::after {
	content: '✔'; line-height: 43px; font-size: 20px; color: rgb(217, 217, 217); text-shadow: rgb(191, 191, 191) 0px -1px 0px;
}

todo-row .todo-item .toggle:checked::after, [is=todo-row] .todo-item .toggle:checked::after {
	color: rgb(133, 173, 167); text-shadow: rgb(102, 153, 145) 0px 1px 0px; bottom: 1px; position: relative;
}

todo-row .todo-item .destroy, [is=todo-row] .todo-item .destroy {
	display: none; position: absolute; top: 0px; right: 10px; bottom: 0px; width: 40px; height: 40px; margin: auto 0px; font-size: 22px; color: rgb(168, 138, 138); transition: all 0.2s; -webkit-transition: all 0.2s;
}

todo-row .todo-item .destroy:hover, [is=todo-row] .todo-item .destroy:hover {
	text-shadow: rgb(0, 0, 0) 0px 0px 1px, rgba(199, 107, 107, 0.8) 0px 0px 10px; -webkit-transform: scale(1.3);
}

todo-row .todo-item .destroy::after, [is=todo-row] .todo-item .destroy::after {
	content: '✖';
}

todo-row .todo-item:hover .destroy, [is=todo-row] .todo-item:hover .destroy {
	display: block;
}

todo-row .todo-item.editing .destroy, [is=todo-row] .todo-item.editing .destroy, todo-row .todo-item.editing .toggle, [is=todo-row] .todo-item.editing .toggle {
	display: none;
}

todo-row .todo-item.editing:last-child, [is=todo-row] .todo-item.editing:last-child {
	margin-bottom: -1px;
}

@media screen and (-webkit-min-device-pixel-ratio: 0) {
todo-row .todo-item .toggle, [is=todo-row] .todo-item .toggle {
	background-image: none; background-position: initial initial; background-repeat: initial initial;
}

todo-row #todo-item .toggle, [is=todo-row] #todo-item .toggle {
	height: 40px;
}


}

</style>
    <div class="todo-item">
      <input class="toggle" type="checkbox">
      <editable-label id="label" value="{{todo.task}}"><shadow-root>
    <template bind="" if="{{!editing}}"></template>
      <label class="edit-label" on-double-click="edit">three (unchecked)</label>
    
    <template bind="" if="{{editing}}"></template>
  </shadow-root></editable-label>
      <button class="destroy" on-click="removeTodo"></button>
    </div>
  </shadow-root></li>
        
      </ul>
    </section>
    <template bind="" if="{{app.todos.length &gt; 0}}"></template>
      <footer id="footer">
        <span id="todo-count"><strong>2</strong></span>
        <ul is="router-options" id="filters"><shadow-root><content></content></shadow-root>
          <li> <a href="#/" class="selected">All</a> </li>
          <li> <a href="#/active" class="">Active</a> </li>
          <li> <a href="#/completed" class="">Completed</a> </li>
        </ul>
        <template bind="" if="{{app.hasCompleteTodos}}"></template>
          <button id="clear-completed" on-click="clear">
            Clear completed (1)
          </button>
        
      </footer>
    
  </section>
  <footer id="info">
    <p>Double-click to edit a todo.</p>
    <p>Credits: the <a href="http://www.dartlang.org">Dart</a> team.</p>
    <p>
      Learn more about
      <a href="https://www.dartlang.org/articles/dart-web-components/">Dart + Web Components</a>
      or
      <a href="https://github.com/dart-lang/web-ui/tree/master/example/todomvc">view the source</a>.
    </p>
    <p>Part of <a href="http://todomvc.com">TodoMVC</a>.</p>
  </footer>
</shadow-root></todo-app>
  


<script type="text/javascript" src="packages/shadow_dom/shadow_dom.debug.js"></script>
<script type="text/javascript" src="packages/browser/interop.js"></script>
<script type="application/dart" src="todomvc_listorder_test.html_bootstrap.dart"></script><script type="text/javascript">(function() {
  // Proxy support for js.dart.

  var globalContext = window;

  // Support for binding the receiver (this) in proxied functions.
  function bindIfFunction(f, _this) {
    if (typeof(f) != "function") {
      return f;
    } else {
      return new BoundFunction(_this, f);
    }
  }

  function unbind(obj) {
    if (obj instanceof BoundFunction) {
      return obj.object;
    } else {
      return obj;
    }
  }

  function getBoundThis(obj) {
    if (obj instanceof BoundFunction) {
      return obj._this;
    } else {
      return globalContext;
    }
  }

  function BoundFunction(_this, object) {
    this._this = _this;
    this.object = object;
  }

  // Table for local objects and functions that are proxied.
  function ProxiedObjectTable() {
    // Name for debugging.
    this.name = 'js-ref';

    // Table from IDs to JS objects.
    this.map = {};

    // Generator for new IDs.
    this._nextId = 0;

    // Counter for deleted proxies.
    this._deletedCount = 0;

    // Flag for one-time initialization.
    this._initialized = false;

    // Ports for managing communication to proxies.
    this.port = new ReceivePortSync();
    this.sendPort = this.port.toSendPort();

    // Set of IDs that are global.
    // These will not be freed on an exitScope().
    this.globalIds = {};

    // Stack of scoped handles.
    this.handleStack = [];

    // Stack of active scopes where each value is represented by the size of
    // the handleStack at the beginning of the scope.  When an active scope
    // is popped, the handleStack is restored to where it was when the
    // scope was entered.
    this.scopeIndices = [];
  }

  // Number of valid IDs.  This is the number of objects (global and local)
  // kept alive by this table.
  ProxiedObjectTable.prototype.count = function () {
    return Object.keys(this.map).length;
  }

  // Number of total IDs ever allocated.
  ProxiedObjectTable.prototype.total = function () {
    return this.count() + this._deletedCount;
  }

  // Adds an object to the table and return an ID for serialization.
  ProxiedObjectTable.prototype.add = function (obj) {
    if (this.scopeIndices.length == 0) {
      throw "Cannot allocate a proxy outside of a scope.";
    }
    // TODO(vsm): Cache refs for each obj?
    var ref = this.name + '-' + this._nextId++;
    this.handleStack.push(ref);
    this.map[ref] = obj;
    return ref;
  }

  ProxiedObjectTable.prototype._initializeOnce = function () {
    if (!this._initialized) {
      this._initialize();
      this._initialized = true;
    }
  }

  // Enters a new scope for this table.
  ProxiedObjectTable.prototype.enterScope = function() {
    this._initializeOnce();
    this.scopeIndices.push(this.handleStack.length);
  }

  // Invalidates all non-global IDs in the current scope and
  // exit the current scope.
  ProxiedObjectTable.prototype.exitScope = function() {
    var start = this.scopeIndices.pop();
    for (var i = start; i < this.handleStack.length; ++i) {
      var key = this.handleStack[i];
      if (!this.globalIds.hasOwnProperty(key)) {
        delete this.map[this.handleStack[i]];
        this._deletedCount++;
      }
    }
    this.handleStack = this.handleStack.splice(0, start);
  }

  // Makes this ID globally scope.  It must be explicitly invalidated.
  ProxiedObjectTable.prototype.globalize = function(id) {
    this.globalIds[id] = true;
  }

  // Invalidates this ID, potentially freeing its corresponding object.
  ProxiedObjectTable.prototype.invalidate = function(id) {
    var old = this.get(id);
    delete this.globalIds[id];
    delete this.map[id];
    this._deletedCount++;
  }

  // Gets the object or function corresponding to this ID.
  ProxiedObjectTable.prototype.get = function (id) {
    if (!this.map.hasOwnProperty(id)) {
      throw 'Proxy ' + id + ' has been invalidated.'
    }
    return this.map[id];
  }

  ProxiedObjectTable.prototype._initialize = function () {
    // Configure this table's port to forward methods, getters, and setters
    // from the remote proxy to the local object.
    var table = this;

    this.port.receive(function (message) {
      // TODO(vsm): Support a mechanism to register a handler here.
      try {
        var object = table.get(message[0]);
        var receiver = unbind(object);
        var member = message[1];
        var kind = message[2];
        var args = message[3].map(deserialize);
        if (kind == 'get') {
          // Getter.
          var field = member;
          if (field in receiver && args.length == 0) {
            var result = bindIfFunction(receiver[field], receiver);
            return [ 'return', serialize(result) ];
          }
        } else if (kind == 'set') {
          // Setter.
          var field = member;
          if (args.length == 1) {
            return [ 'return', serialize(receiver[field] = args[0]) ];
          }
        } else if (kind == 'apply') {
          // Direct function invocation.
          var _this = getBoundThis(object);
          return [ 'return', serialize(receiver.apply(_this, args)) ];
        } else if (member == '[]' && args.length == 1) {
          // Index getter.
          var result = bindIfFunction(receiver[args[0]], receiver);
          return [ 'return', serialize(result) ];
        } else if (member == '[]=' && args.length == 2) {
          // Index setter.
          return [ 'return', serialize(receiver[args[0]] = args[1]) ];
        } else {
          // Member function invocation.
          var f = receiver[member];
          if (f) {
            var result = f.apply(receiver, args);
            return [ 'return', serialize(result) ];
          }
        }
        return [ 'none' ];
      } catch (e) {
        return [ 'throws', e.toString() ];
      }
    });
  }

  // Singleton for local proxied objects.
  var proxiedObjectTable = new ProxiedObjectTable();

  // DOM element serialization code.
  var _localNextElementId = 0;
  var _DART_ID = 'data-dart_id';
  var _DART_TEMPORARY_ATTACHED = 'data-dart_temporary_attached';

  function serializeElement(e) {
    // TODO(vsm): Use an isolate-specific id.
    var id;
    if (e.hasAttribute(_DART_ID)) {
      id = e.getAttribute(_DART_ID);
    } else {
      id = (_localNextElementId++).toString();
      e.setAttribute(_DART_ID, id);
    }
    if (e !== document.documentElement) {
      // Element must be attached to DOM to be retrieve in js part.
      // Attach top unattached parent to avoid detaching parent of "e" when
      // appending "e" directly to document. We keep count of elements
      // temporarily attached to prevent detaching top unattached parent to
      // early. This count is equals to the length of _DART_TEMPORARY_ATTACHED
      // attribute. There could be other elements to serialize having the same
      // top unattached parent.
      var top = e;
      while (true) {
        if (top.hasAttribute(_DART_TEMPORARY_ATTACHED)) {
          var oldValue = top.getAttribute(_DART_TEMPORARY_ATTACHED);
          var newValue = oldValue + "a";
          top.setAttribute(_DART_TEMPORARY_ATTACHED, newValue);
          break;
        }
        if (top.parentNode == null) {
          top.setAttribute(_DART_TEMPORARY_ATTACHED, "a");
          document.documentElement.appendChild(top);
          break;
        }
        if (top.parentNode === document.documentElement) {
          // e was already attached to dom
          break;
        }
        top = top.parentNode;
      }
    }
    return id;
  }

  function deserializeElement(id) {
    // TODO(vsm): Clear the attribute.
    var list = document.querySelectorAll('[' + _DART_ID + '="' + id + '"]');

    if (list.length > 1) throw 'Non unique ID: ' + id;
    if (list.length == 0) {
      throw 'Element must be attached to the document: ' + id;
    }
    var e = list[0];
    if (e !== document.documentElement) {
      // detach temporary attached element
      var top = e;
      while (true) {
        if (top.hasAttribute(_DART_TEMPORARY_ATTACHED)) {
          var oldValue = top.getAttribute(_DART_TEMPORARY_ATTACHED);
          var newValue = oldValue.substring(1);
          top.setAttribute(_DART_TEMPORARY_ATTACHED, newValue);
          // detach top only if no more elements have to be unserialized
          if (top.getAttribute(_DART_TEMPORARY_ATTACHED).length === 0) {
            top.removeAttribute(_DART_TEMPORARY_ATTACHED);
            document.documentElement.removeChild(top);
          }
          break;
        }
        if (top.parentNode === document.documentElement) {
          // e was already attached to dom
          break;
        }
        top = top.parentNode;
      }
    }
    return e;
  }


  // Type for remote proxies to Dart objects.
  function DartProxy(id, sendPort) {
    this.id = id;
    this.port = sendPort;
  }

  // Serializes JS types to SendPortSync format:
  // - primitives -> primitives
  // - sendport -> sendport
  // - DOM element -> [ 'domref', element-id ]
  // - Function -> [ 'funcref', function-id, sendport ]
  // - Object -> [ 'objref', object-id, sendport ]
  function serialize(message) {
    if (message == null) {
      return null;  // Convert undefined to null.
    } else if (typeof(message) == 'string' ||
               typeof(message) == 'number' ||
               typeof(message) == 'boolean') {
      // Primitives are passed directly through.
      return message;
    } else if (message instanceof SendPortSync) {
      // Non-proxied objects are serialized.
      return message;
    } else if (message instanceof Element &&
        (message.ownerDocument == null || message.ownerDocument == document)) {
      return [ 'domref', serializeElement(message) ];
    } else if (message instanceof BoundFunction &&
               typeof(message.object) == 'function') {
      // Local function proxy.
      return [ 'funcref',
               proxiedObjectTable.add(message),
               proxiedObjectTable.sendPort ];
    } else if (typeof(message) == 'function') {
      if ('_dart_id' in message) {
        // Remote function proxy.
        var remoteId = message._dart_id;
        var remoteSendPort = message._dart_port;
        return [ 'funcref', remoteId, remoteSendPort ];
      } else {
        // Local function proxy.
        return [ 'funcref',
                 proxiedObjectTable.add(message),
                 proxiedObjectTable.sendPort ];
      }
    } else if (message instanceof DartProxy) {
      // Remote object proxy.
      return [ 'objref', message.id, message.port ];
    } else {
      // Local object proxy.
      return [ 'objref',
               proxiedObjectTable.add(message),
               proxiedObjectTable.sendPort ];
    }
  }

  function deserialize(message) {
    if (message == null) {
      return null;  // Convert undefined to null.
    } else if (typeof(message) == 'string' ||
               typeof(message) == 'number' ||
               typeof(message) == 'boolean') {
      // Primitives are passed directly through.
      return message;
    } else if (message instanceof SendPortSync) {
      // Serialized type.
      return message;
    }
    var tag = message[0];
    switch (tag) {
      case 'funcref': return deserializeFunction(message);
      case 'objref': return deserializeObject(message);
      case 'domref': return deserializeElement(message[1]);
    }
    throw 'Unsupported serialized data: ' + message;
  }

  // Create a local function that forwards to the remote function.
  function deserializeFunction(message) {
    var id = message[1];
    var port = message[2];
    // TODO(vsm): Add a more robust check for a local SendPortSync.
    if ("receivePort" in port) {
      // Local function.
      return unbind(proxiedObjectTable.get(id));
    } else {
      // Remote function.  Forward to its port.
      var f = function () {
        var depth = enterScope();
        try {
          var args = Array.prototype.slice.apply(arguments);
          args.splice(0, 0, this);
          args = args.map(serialize);
          var result = port.callSync([id, '#call', args]);
          if (result[0] == 'throws') throw deserialize(result[1]);
          return deserialize(result[1]);
        } finally {
          exitScope(depth);
        }
      };
      // Cache the remote id and port.
      f._dart_id = id;
      f._dart_port = port;
      return f;
    }
  }

  // Creates a DartProxy to forwards to the remote object.
  function deserializeObject(message) {
    var id = message[1];
    var port = message[2];
    // TODO(vsm): Add a more robust check for a local SendPortSync.
    if ("receivePort" in port) {
      // Local object.
      return proxiedObjectTable.get(id);
    } else {
      // Remote object.
      return new DartProxy(id, port);
    }
  }

  // Remote handler to construct a new JavaScript object given its
  // serialized constructor and arguments.
  function construct(args) {
    args = args.map(deserialize);
    var constructor = unbind(args[0]);
    args = Array.prototype.slice.call(args, 1);

    // Until 10 args, the 'new' operator is used. With more arguments we use a
    // generic way that may not work, particulary when the constructor does not
    // have an "apply" method.
    var ret = null;
    if (args.length === 0) {
      ret = new constructor();
    } else if (args.length === 1) {
      ret = new constructor(args[0]);
    } else if (args.length === 2) {
      ret = new constructor(args[0], args[1]);
    } else if (args.length === 3) {
      ret = new constructor(args[0], args[1], args[2]);
    } else if (args.length === 4) {
      ret = new constructor(args[0], args[1], args[2], args[3]);
    } else if (args.length === 5) {
      ret = new constructor(args[0], args[1], args[2], args[3], args[4]);
    } else if (args.length === 6) {
      ret = new constructor(args[0], args[1], args[2], args[3], args[4],
                            args[5]);
    } else if (args.length === 7) {
      ret = new constructor(args[0], args[1], args[2], args[3], args[4],
                            args[5], args[6]);
    } else if (args.length === 8) {
      ret = new constructor(args[0], args[1], args[2], args[3], args[4],
                            args[5], args[6], args[7]);
    } else if (args.length === 9) {
      ret = new constructor(args[0], args[1], args[2], args[3], args[4],
                            args[5], args[6], args[7], args[8]);
    } else if (args.length === 10) {
      ret = new constructor(args[0], args[1], args[2], args[3], args[4],
                            args[5], args[6], args[7], args[8], args[9]);
    } else {
      // Dummy Type with correct constructor.
      var Type = function(){};
      Type.prototype = constructor.prototype;
  
      // Create a new instance
      var instance = new Type();
  
      // Call the original constructor.
      ret = constructor.apply(instance, args);
      ret = Object(ret) === ret ? ret : instance;
    }
    return serialize(ret);
  }

  // Remote handler to return the top-level JavaScript context.
  function context(data) {
    return serialize(globalContext);
  }

  // Remote handler to track number of live / allocated proxies.
  function proxyCount() {
    var live = proxiedObjectTable.count();
    var total = proxiedObjectTable.total();
    return [live, total];
  }

  // Return true if two JavaScript proxies are equal (==).
  function proxyEquals(args) {
    return deserialize(args[0]) == deserialize(args[1]);
  }

  // Return true if a JavaScript proxy is instance of a given type (instanceof).
  function proxyInstanceof(args) {
    var obj = unbind(deserialize(args[0]));
    var type = unbind(deserialize(args[1]));
    return obj instanceof type;
  }

  // Return true if a JavaScript proxy has a given property.
  function proxyHasProperty(args) {
    var obj = unbind(deserialize(args[0]));
    var member = unbind(deserialize(args[1]));
    return member in obj;
  }

  // Delete a given property of object.
  function proxyDeleteProperty(args) {
    var obj = unbind(deserialize(args[0]));
    var member = unbind(deserialize(args[1]));
    delete obj[member];
  }

  function proxyConvert(args) {
    return serialize(deserializeDataTree(args));
  }

  function deserializeDataTree(data) {
    var type = data[0];
    var value = data[1];
    if (type === 'map') {
      var obj = {};
      for (var i = 0; i < value.length; i++) {
        obj[value[i][0]] = deserializeDataTree(value[i][1]);
      }
      return obj;
    } else if (type === 'list') {
      var list = [];
      for (var i = 0; i < value.length; i++) {
        list.push(deserializeDataTree(value[i]));
      }
      return list;
    } else /* 'simple' */ {
      return deserialize(value);
    }
  }

  function makeGlobalPort(name, f) {
    var port = new ReceivePortSync();
    port.receive(f);
    window.registerPort(name, port.toSendPort());
  }

  // Enters a new scope in the JavaScript context.
  function enterJavaScriptScope() {
    proxiedObjectTable.enterScope();
  }

  // Enters a new scope in both the JavaScript and Dart context.
  var _dartEnterScopePort = null;
  function enterScope() {
    enterJavaScriptScope();
    if (!_dartEnterScopePort) {
      _dartEnterScopePort = window.lookupPort('js-dart-interop-enter-scope');
    }
    return _dartEnterScopePort.callSync([]);
  }

  // Exits the current scope (and invalidate local IDs) in the JavaScript
  // context.
  function exitJavaScriptScope() {
    proxiedObjectTable.exitScope();
  }

  // Exits the current scope in both the JavaScript and Dart context.
  var _dartExitScopePort = null;
  function exitScope(depth) {
    exitJavaScriptScope();
    if (!_dartExitScopePort) {
      _dartExitScopePort = window.lookupPort('js-dart-interop-exit-scope');
    }
    return _dartExitScopePort.callSync([ depth ]);
  }

  makeGlobalPort('dart-js-interop-context', context);
  makeGlobalPort('dart-js-interop-create', construct);
  makeGlobalPort('dart-js-interop-proxy-count', proxyCount);
  makeGlobalPort('dart-js-interop-equals', proxyEquals);
  makeGlobalPort('dart-js-interop-instanceof', proxyInstanceof);
  makeGlobalPort('dart-js-interop-has-property', proxyHasProperty);
  makeGlobalPort('dart-js-interop-delete-property', proxyDeleteProperty);
  makeGlobalPort('dart-js-interop-convert', proxyConvert);
  makeGlobalPort('dart-js-interop-enter-scope', enterJavaScriptScope);
  makeGlobalPort('dart-js-interop-exit-scope', exitJavaScriptScope);
  makeGlobalPort('dart-js-interop-globalize', function(data) {
    if (data[0] == "objref" || data[0] == "funcref") return proxiedObjectTable.globalize(data[1]);
    throw 'Illegal type: ' + data[0];
  });
  makeGlobalPort('dart-js-interop-invalidate', function(data) {
    if (data[0] == "objref" || data[0] == "funcref") return proxiedObjectTable.invalidate(data[1]);
    throw 'Illegal type: ' + data[0];
  });
})();
</script></body></html>
